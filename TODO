# -*- org -*-
* TODO Graph
  Graph based on input words, where the weight is the number of times
  a letter follows another (or precedes?) (this is Markov, isn't it?);
  and an frequency table of letters to seed the guesses.

  Then we do a Dijkstra weighted--shortest-path and greedy
  optimization?

  At some point we need to do a calculation, though, don't we: given
  that we have so many guesses left, etc., what's the cost of guessing
  a word vs. guessing a letter?

  We have neither secretWord nor maxWrongGuesses, though.

  Going with the Dijkstra analogy, we remove edges for wrong guesses;
  each edge represents a potential digram. (Could this be improved
  with n-grams, etc.?)

  1. Get the game;
  2. determine how many letters;
  3. take appropriate words;
  4. build a frequency table for initial guesses (randomizing and
     eliminating ties?);
  5. build a weighted digram graph;
  6. guess correctly: prune the graph (all paths at index {a1, ..., an}
     converge on a) (question is: do we distinguish between letter
     e.g. `a' at positions e.g. 1 and 3? If we permit cycles, the
     links have lower quality; how do we reference index i in the
     graph, though? We do have some starting nodes and perhaps even a
     forest (shit: one graph for each starting letter));
  7. guess incorrectly: prune the graph (no such letter exists).

  We're dealing with a sort of tree here, aren't we, whose leaves are
  words? In other words, given a sequence of correct guesses; it
  should be unambiguous that it signifies a given word. Better yet: we
  should be able to determine the set of signifiable words; we could
  have some heuristic: possible words vs. =maxWrongGuesses=, but I
  don't think we have =maxWrongGuesses=.

  Not true! We have =numWrongGuessesRemaning()= and
  =getMaxWrongGuesses()=. =getSecretWordLength()=: nice! That's what I
  was looking for.

  If =numWrongGuessesRemaning= > $|signifiableWords|$, then we can
  clearly guess all the $\{signifiableWords\}$ one-by-one.

  Thing we're missing is: how do we go from an incompletely determined
  graph to possible words? That's why I suspect we're dealing with,
  not a tree per se, but a graph with terminal vertices; graph if we
  converge on letters: i.e. $\text{c}_1 \to \text{a}_2 \to
  \text{b}_3$, $\text{f}_1 \to \text{a}_2 \to \text{b}_3$; as opposed
  to: $\text{c}_{1_1} \to \text{a}_{2_1} \to \text{b}_{3_1}$,
  $\text{f}_{1_1} \to \text{a}_{2_2} \to \text{b}_{3_2}$. Convergence
  seems to make sense from a space point-of-view, as well as
  determining convergent paths.

  Create a special root node: one artificial graph (graph with
  terminal vertices, not a tree).

  #+BEGIN_SRC makefile :tangle graph.mk :shebang #!/usr/bin/unexpand -t 4
    CLASSPATH := .:$(shell echo lib/*.jar | tr ' ' ':')
    SOURCE := $(wildcard *.java) $(wildcard *.scm)
    OBJECTS := $(patsubst %.java,%.class,$(wildcard *.java)) \
        $(patsubst %.scm,%.scc,$(wildcard *.scm))
    
    .PHONY: test
    
    %.class : %.java
        javac -classpath $(CLASSPATH) $<
    
    %.scc : %.scm
        sisc -e "(compile-file \"$<\" \"$@\")"
    
    test: all
        java -classpath $(CLASSPATH) Hangman words.txt factual
    
    all: $(OBJECTS)
    
  #+END_SRC

  #+BEGIN_SRC java :tangle Hangman.java
    import java.lang.reflect.Array;
    import java.util.Arrays;
    import java.util.Queue;
    import java.io.IOException;
    
    import sisc.interpreter.Interpreter;
    import sisc.interpreter.Context;
    import sisc.interpreter.SchemeCaller;
    import sisc.interpreter.SchemeException;
    import sisc.data.EmptyList;
    import sisc.data.Symbol;
    import sisc.data.Pair;
    import sisc.data.Value;
    import sisc.data.SchemeString;
    import sisc.util.Util;
    import sisc.modules.s2j.JavaObject;
    
    public class Hangman {
        public static final int maxWrongGuesses = 5;
    
        public static int run(HangmanGame game, GuessingStrategy strategy) {
            return 0;
        }
    
        public static void main(final String[] args) throws SchemeException, IOException {
            String dictionary = args[0];
            String[] words = Arrays.copyOfRange(args, 1, args.length);
            for (String word: words) {
                HangmanGame game = new HangmanGame(word, maxWrongGuesses);
                GuessingStrategy strategy = new GraphGuessingStrategy(dictionary, game);
                run(game, strategy);
            }
        }
    }
    
  #+END_SRC

  #+BEGIN_SRC scheme :tangle hangman.scm
    (import s2j)
    
    (define-syntax debug
      (syntax-rules ()
        ((_ x ...)
         (begin
           (write `((x ,x) ...))
           (newline)))))
    
    (define-java-classes
      <guessing-strategy>
      <hangman-game>
      <hangman>)
    
    (define-java-proxy
      (guessing-strategy dictionary game)
      (<guessing-strategy>)
      (define x 2)
      #;
      (define (guessing-strategy dictionary game)
        (set! x 3)
        (debug x))
      (define (next-guess game)
        #;(game get-secret-word-length)
        2))
    
    ;; (debug (java-proxy-class <hangman-game>))
    ;; (debug (java-class-name <hangman-game>)
    ;;        (java-method-name guessing-strategy))
    
    ;; (define-generic-java-methods next-guess)
    ;; (define-generic-java-field-accessors :next-guess)
    
    (define (make-dictionary dictionary)
      (with-input-from-file
          dictionary
        (lambda ()
          (unfold ))))
    
    (define (init strategy dictionary game)
      (debug 2)
      2)
    
    (define (main argv)
      (let ((dictionary (car argv))
            (words (cdr argv)))
        (debug 2 dictionary words)
        ;; (debug (java-new <java.util.linked-hash-set> (->jint 100)))
        ;; (debug (java-new <hangman-game> (->jstring "factual") (->jint 4)))
        (let* ((game (java-new <hangman-game> (->jstring "factual") (->jint 4)))
               (strategy (guessing-strategy dictionary game)))
          strategy)
        #;
        (let ((game (java-new <hangman-game> (->jstring "factual") (->jint 4))))
          (debug game))
    
        ;; (java-new <hangman-game> (->jstring "oeunth") (->jint 5))
        ;; (java-new <hangman-game> "oeuhnt" 5)
        #;
        (with-input-from-file
        dictionary
        (lambda ()
        (let next-word ((word (read)))
        (if (eof-object? word)
        0
        (begin
        (debug word)
        (next-word (read)))))))))
    
  #+END_SRC

  I'm going to assume that the program takes a dictionary file and
  list of words; and that I have to program the glue.

  How is this going to work with initialization, etc.? For clarity,
  should we implement the interface in Java, there to defer to Scheme?

  No, let's do it in Scheme. (Risky.)
  
  We'll define the main run-loop in Java (=run(game, strategy)=); the
  creation of the strategy, however, will defer to Scheme (=new
  GraphStrategy(dictionary)=).

  #+BEGIN_SRC java :tangle GraphGuessingStrategy.java
    import java.io.IOException;
    
    import sisc.interpreter.Interpreter;
    import sisc.interpreter.Context;
    import sisc.interpreter.SchemeCaller;
    import sisc.interpreter.SchemeException;
    import sisc.data.EmptyList;
    import sisc.data.Symbol;
    import sisc.data.Pair;
    import sisc.data.Value;
    import sisc.data.SchemeString;
    import sisc.util.Util;
    import sisc.modules.s2j.JavaObject;
    
    public class GraphGuessingStrategy implements GuessingStrategy {
        
    
        public Guess nextGuess(HangmanGame game) {
            return new Guess() {
                public void makeGuess(HangmanGame game) {
                }
            };
        }
    
        // Let this take, instead, a dictionary-graph.
        public GraphGuessingStrategy(final String dictionary, final HangmanGame game) throws SchemeException {
            Context.execute(new SchemeCaller() {
                    public Object execute(Interpreter interpreter) throws SchemeException {
                        interpreter.loadSourceFiles(new String[] { "hangman.scc" });
                        try {
                            interpreter.eval(Util.proc(interpreter.eval("init")),
                                             new Value[] {
                                                 new JavaObject(this),
                                                 new SchemeString(dictionary),
                                                 new JavaObject(game)
                                             });
                        } catch (Throwable e) {
                            e.printStackTrace();
                        };
                        return true;
                    }
                });
        }
    }
    
  #+END_SRC

  Let's initialize a "strategy-factory" with the dictionary that
  creates a graph for each class of words with letters $2 .. n$. No,
  fuck that: initialize the =GraphGuessingStrategy= with the
  dictionary-graph.

  How do we share the graphs, though? Either it's some sort of opaque
  scheme-object corresponding to, say, a hash-table; or it's some Java
  object (say, =java.util.HashTable=) with which we have to interact
  from Scheme. What are the performance characteristics of both
  scenarios?

  For convenience, I'd rather have Scheme objects to pass around (a
  =Value=, essentially).

  (Oh, check it out: they have a [[http://sisc-scheme.org/manual/javadoc/sisc/modules/hashtable/Hashtable.html][Hashtable]] interface.)

  #+BEGIN_SRC scheme :tangle unfold-file.scm
    (require-library 'sisc/libs/srfi/srfi-1)
    (import srfi-1)
    (import s2j)
    ;; (load "irregex-0.8.1/irregex.scm")
    ;; (require-extension (lib scsh-regexp/scsh-regexp))
    ;; (import scsh-regexp/scsh-regexp)
    
    (define-java-classes
      <java.lang.string>
      <java.util.regex.pattern>)
    
    (define-generic-java-methods
      matches)
    
    (let ((dictionary
           (with-input-from-file
               "words.txt"
             (lambda ()
               (let next-word ((word (read))
                               (dictionary '()))
                 (if (eof-object? word)
                     dictionary
                     (next-word
                      (read)
                      (cons (->jstring word) dictionary))))))))
      #;
      (let ((pattern (->jstring "...")))
        (filter (lambda (word)
                  (->boolean (matches word pattern)))
                dictionary))
      ;; Adds 6 sec.
      #;
      (let ((pattern (->jstring ".......")))
        (filter (lambda (word)
                  (->boolean (matches word pattern)))
                dictionary))
      ;; Adds 6 sec.
      #;
      (let ((pattern (->jstring "...a...")))
        (filter (lambda (word)
                  (->boolean (matches word pattern)))
                dictionary))
      ;; Adds 4 sec; should we bother compiling the regex?
      (let ((pattern (->jstring "...a...")))
        (filter (lambda (word)
                  (->boolean (matches word pattern)))
                (let ((pattern (->jstring ".......")))
                  (filter (lambda (word)
                            (->boolean (matches word pattern)))
                          dictionary))))
      2
      #;
      (for-each (lambda (word)
      'harro
      ;; (irregex-match '(w/nocase ".*") word)
      ;; (matches (->jstring word) (->jstring ".?"))
      #;
      (let ((word (java-new <java.lang.string> (->jstring word))))
      (matches (java-null <java.util.regex.pattern>) word (->jstring ".?"))))
      dictionary))
    
  #+END_SRC

  The issue is: either we have to deal with Scheme strings, Java
  strings or some kind of conversion; the conversion is relatively
  slow (have to do so for e.g. =java.lang.String.match()=); and
  irregex doesn't work (otherwise we could stick with Scheme strings).

  Can we do slow regex for now, and replace it with some e.g. trie
  algo later?

  I just realized that the chaining doesn't matter; we're only dealing
  with frequency, I believe. Could roughly:

  1. Filter the current dictionary based on =getGuessedSoFar()= (this
     could be a string->regex substitution for now and would thus
     carry an O(n * O(regex)) penalty; some sort of e.g. trie-based
     search might get us log-linear).
  2. Is the $|current dictionary| < numWrongGuessesRemaning$? Guess!
  3. Build a frequency list of letters.
  4. Guess one of the most frequent letters; remove it.
  5. Wrong?
     1. Guess again.
  6. Right?
     1. Goto 1.

  Just met Aaron at the Hacker News meetup: drop Scheme, adopt
  Clojure.

  [[http://stackoverflow.com/questions/6339473/python-regex-hangman-algorithm][This]] is subtle, by the way: regexps are susceptible to false
  positives. From the same page:

  #+BEGIN_QUOTE
  As far as determining the next character to guess, you probably
  don't want to select the most frequent character. Instead, you want
  to select the character that comes closest to being in 50% of words,
  meaning you eliminate the most possibilities either way.
  #+END_QUOTE

  Also:

  #+BEGIN_QUOTE
  Your regex should look more like this: '^e[^e][^e][^e][^e]e[^e]$'.
  #+END_QUOTE

  Good call.

  [[http://qs343.pair.com/~monkperl/index.pl?node_id=780414][Frequency and density]]; also: probability that letter is in a given
  position!

  #+BEGIN_QUOTE
  From this, you can easily duplicate my algorithm by determining
  which letter to choose based on which word appears in the most
  candidate words (highest probability of being right) and break ties
  by using the highest overall density.
  #+END_QUOTE

  #+BEGIN_QUOTE
  First, a 1 size fits all algorithm that weighs various different
  pieces of data to produce an overall score. The advantage here is
  that you should be able to tune these weights without touching code
  to produce the best results for a given "dictionary". The second
  approach would be to have multiple algorithms already fine tuned for
  a given set of conditions and dispatch to that algorithm based on
  initial conditions. For instance, it may be ok to take a risk of
  guessing wrong if the remaining wrong guesses is still high or
  perhaps utilize the "simple" algorithm already presented unless the
  probabilities and candidates remaining (if right or wrong) is beyond
  some threshold.
  #+END_QUOTE

  The Markov chains come up again:

  #+BEGIN_QUOTE
  An higher order approach would be to look at probabilities for
  chains of letters. E. g. in English the chance for an 'u' should be
  higher than average after a 'q'.
  #+END_QUOTE

  He's right, actually: looking at mere frequency represents a loss of
  data (`q' followed by `u', for instance, is not handled). Let's
  revisit the Markov idea.

  On the other hand, maybe I was right:

  #+BEGIN_QUOTE
  If 'q' is guessed and is correct, then the next time around, 'u' will
  already jump to the top of the list of letters with the most
  probability to be correct. You don't need to know any special
  knowledge about letter frequency (alone or in chains) to get this benefit.
  #+END_QUOTE

  [[http://qs343.pair.com/~monkperl/index.pl?node_id=779296][Original post]]; this guy is suggesting some kind of binary search:

  #+BEGIN_QUOTE
  At least in your example, a letter never appears in more than half
  of the candidates, so the most frequent letter and the
  closest-to-half-half letter coincide. But imagine if you found out
  that the actual word contained Q. Then for sure the next most common
  letter will be a U; but guessing U and getting it right will not
  give you much new information. Aiming for half-half lets your
  correct and incorrect guesses both contribute information.
  #+END_QUOTE

  

* TODO Clojure
  On [[http://blog.8thlight.com/articles/2010/12/6/clojure-libs-and-namespaces-require-use-import-and-ns][namespaces]]; let's relegate factual's hangman to
  src/com/factual/hangman, or should we create a separate repo
  containing a jar?
